/*
 * navitia
 *      navitia.io is the open API for building cool stuff with mobility data. It provides the following services      * journeys computation     * line schedules     * next departures     * exploration of public transport data / search places     * and sexy things such as isochrones      navitia is a HATEOAS API that returns JSON formated results
 *
 * OpenAPI spec version: v15.75.4
 * Contact: navitia@googlegroups.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.gdamiens.website.idfm.navitia.api;

import io.swagger.client.ApiCallback;
import io.swagger.client.ApiClient;
import io.swagger.client.ApiException;
import io.swagger.client.ApiResponse;
import io.swagger.client.Configuration;
import io.swagger.client.Pair;
import io.swagger.client.ProgressRequestBody;
import io.swagger.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.math.BigDecimal;
import io.swagger.client.model.GraphicalIsrochone1;
import org.threeten.bp.OffsetDateTime;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class GraphicalIsochroneApi {
    private ApiClient apiClient;
    private Map<String, String> headers;

    public GraphicalIsochroneApi() {
        this(Configuration.getDefaultApiClient());
    }

    public GraphicalIsochroneApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public void setHeadersOverrides(Map<String, String> headers) {
        this.headers = headers;
    }

    /**
     * Build call for getCoverageLonLatIsochrones
     * @param lon The longitude of where the coord you want to query (required)
     * @param lat The latitude of where the coord you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param maxCarNoParkDurationToPt Maximal duration of car no park on public transport in second (optional)
     * @param maxTaxiDurationToPt Maximal duration of taxi on public transport in second, only available in distributed scenario (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carNoParkSpeed Driving speed without car park for the fallback sections. Speed unit must be in meter/second (optional)
     * @param taxiSpeed taxi speed speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;realtime&#39; - Use all realtime information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule. (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param directPathMode Force the direct-path modes.If this list is not empty, we only compute direct_path for modes in this listAnd filter all the direct_paths of modes in first_section_mode[] (optional)
     * @param partnerServices Expose only the partner type into the response. (optional)
     * @param additionalTimeAfterFirstSectionTaxi the additional time added to the taxi section, right after riding the taxi but before hopping on the public transit (optional)
     * @param additionalTimeBeforeLastSectionTaxi the additional time added to the taxi section, right before riding the taxi but after hopping off the public transit (optional)
     * @param criteria choose the criteria used to compute pt journeys, feature in beta  (optional)
     * @param minDuration Minimum travel duration (optional)
     * @param boundaryDuration To provide multiple duration parameters (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getCoverageLonLatIsochronesCall(BigDecimal lon, BigDecimal lat, String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer minDuration, List<Integer> boundaryDuration, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/coverage/{lon};{lat}/isochrones"
            .replaceAll("\\{" + "lon" + "\\}", apiClient.escapeString(lon.toString()))
            .replaceAll("\\{" + "lat" + "\\}", apiClient.escapeString(lat.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (from != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("from", from));
        if (to != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("to", to));
        if (datetime != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("datetime", datetime));
        if (datetimeRepresents != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("datetime_represents", datetimeRepresents));
        if (maxNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_nb_transfers", maxNbTransfers));
        if (minNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("min_nb_transfers", minNbTransfers));
        if (firstSectionMode != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "first_section_mode[]", firstSectionMode));
        if (lastSectionMode != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "last_section_mode[]", lastSectionMode));
        if (maxDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_duration_to_pt", maxDurationToPt));
        if (maxWalkingDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_walking_duration_to_pt", maxWalkingDurationToPt));
        if (maxBikeDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_bike_duration_to_pt", maxBikeDurationToPt));
        if (maxBssDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_bss_duration_to_pt", maxBssDurationToPt));
        if (maxCarDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_car_duration_to_pt", maxCarDurationToPt));
        if (maxRidesharingDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_ridesharing_duration_to_pt", maxRidesharingDurationToPt));
        if (maxCarNoParkDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_car_no_park_duration_to_pt", maxCarNoParkDurationToPt));
        if (maxTaxiDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_taxi_duration_to_pt", maxTaxiDurationToPt));
        if (walkingSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("walking_speed", walkingSpeed));
        if (bikeSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("bike_speed", bikeSpeed));
        if (bssSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("bss_speed", bssSpeed));
        if (carSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("car_speed", carSpeed));
        if (ridesharingSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("ridesharing_speed", ridesharingSpeed));
        if (carNoParkSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("car_no_park_speed", carNoParkSpeed));
        if (taxiSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("taxi_speed", taxiSpeed));
        if (forbiddenUris != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "forbidden_uris[]", forbiddenUris));
        if (allowedId != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "allowed_id[]", allowedId));
        if (disruptionActive != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("disruption_active", disruptionActive));
        if (dataFreshness != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("data_freshness", dataFreshness));
        if (maxDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_duration", maxDuration));
        if (wheelchair != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("wheelchair", wheelchair));
        if (travelerType != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("traveler_type", travelerType));
        if (directPath != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("direct_path", directPath));
        if (freeRadiusFrom != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("free_radius_from", freeRadiusFrom));
        if (freeRadiusTo != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("free_radius_to", freeRadiusTo));
        if (directPathMode != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "direct_path_mode[]", directPathMode));
        if (partnerServices != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "partner_services[]", partnerServices));
        if (additionalTimeAfterFirstSectionTaxi != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("additional_time_after_first_section_taxi", additionalTimeAfterFirstSectionTaxi));
        if (additionalTimeBeforeLastSectionTaxi != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("additional_time_before_last_section_taxi", additionalTimeBeforeLastSectionTaxi));
        if (criteria != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("criteria", criteria));
        if (minDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("min_duration", minDuration));
        if (boundaryDuration != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "boundary_duration[]", boundaryDuration));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        if (headers != null) {
            localVarHeaderParams.putAll(headers);
        }
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getCoverageLonLatIsochronesValidateBeforeCall(BigDecimal lon, BigDecimal lat, String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer minDuration, List<Integer> boundaryDuration, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // verify the required parameter 'lon' is set
        if (lon == null) {
            throw new ApiException("Missing the required parameter 'lon' when calling getCoverageLonLatIsochrones(Async)");
        }

        // verify the required parameter 'lat' is set
        if (lat == null) {
            throw new ApiException("Missing the required parameter 'lat' when calling getCoverageLonLatIsochrones(Async)");
        }


        com.squareup.okhttp.Call call = getCoverageLonLatIsochronesCall(lon, lat, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, maxCarNoParkDurationToPt, maxTaxiDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, carNoParkSpeed, taxiSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, directPathMode, partnerServices, additionalTimeAfterFirstSectionTaxi, additionalTimeBeforeLastSectionTaxi, criteria, minDuration, boundaryDuration, progressListener, progressRequestListener);
        return call;

    }

    /**
     *
     *
     * @param lon The longitude of where the coord you want to query (required)
     * @param lat The latitude of where the coord you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param maxCarNoParkDurationToPt Maximal duration of car no park on public transport in second (optional)
     * @param maxTaxiDurationToPt Maximal duration of taxi on public transport in second, only available in distributed scenario (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carNoParkSpeed Driving speed without car park for the fallback sections. Speed unit must be in meter/second (optional)
     * @param taxiSpeed taxi speed speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;realtime&#39; - Use all realtime information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule. (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param directPathMode Force the direct-path modes.If this list is not empty, we only compute direct_path for modes in this listAnd filter all the direct_paths of modes in first_section_mode[] (optional)
     * @param partnerServices Expose only the partner type into the response. (optional)
     * @param additionalTimeAfterFirstSectionTaxi the additional time added to the taxi section, right after riding the taxi but before hopping on the public transit (optional)
     * @param additionalTimeBeforeLastSectionTaxi the additional time added to the taxi section, right before riding the taxi but after hopping off the public transit (optional)
     * @param criteria choose the criteria used to compute pt journeys, feature in beta  (optional)
     * @param minDuration Minimum travel duration (optional)
     * @param boundaryDuration To provide multiple duration parameters (optional)
     * @return GraphicalIsrochone1
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public GraphicalIsrochone1 getCoverageLonLatIsochrones(BigDecimal lon, BigDecimal lat, String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer minDuration, List<Integer> boundaryDuration) throws ApiException {
        ApiResponse<GraphicalIsrochone1> resp = getCoverageLonLatIsochronesWithHttpInfo(lon, lat, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, maxCarNoParkDurationToPt, maxTaxiDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, carNoParkSpeed, taxiSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, directPathMode, partnerServices, additionalTimeAfterFirstSectionTaxi, additionalTimeBeforeLastSectionTaxi, criteria, minDuration, boundaryDuration);
        return resp.getData();
    }

    /**
     *
     *
     * @param lon The longitude of where the coord you want to query (required)
     * @param lat The latitude of where the coord you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param maxCarNoParkDurationToPt Maximal duration of car no park on public transport in second (optional)
     * @param maxTaxiDurationToPt Maximal duration of taxi on public transport in second, only available in distributed scenario (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carNoParkSpeed Driving speed without car park for the fallback sections. Speed unit must be in meter/second (optional)
     * @param taxiSpeed taxi speed speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;realtime&#39; - Use all realtime information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule. (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param directPathMode Force the direct-path modes.If this list is not empty, we only compute direct_path for modes in this listAnd filter all the direct_paths of modes in first_section_mode[] (optional)
     * @param partnerServices Expose only the partner type into the response. (optional)
     * @param additionalTimeAfterFirstSectionTaxi the additional time added to the taxi section, right after riding the taxi but before hopping on the public transit (optional)
     * @param additionalTimeBeforeLastSectionTaxi the additional time added to the taxi section, right before riding the taxi but after hopping off the public transit (optional)
     * @param criteria choose the criteria used to compute pt journeys, feature in beta  (optional)
     * @param minDuration Minimum travel duration (optional)
     * @param boundaryDuration To provide multiple duration parameters (optional)
     * @return ApiResponse&lt;GraphicalIsrochone1&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<GraphicalIsrochone1> getCoverageLonLatIsochronesWithHttpInfo(BigDecimal lon, BigDecimal lat, String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer minDuration, List<Integer> boundaryDuration) throws ApiException {
        com.squareup.okhttp.Call call = getCoverageLonLatIsochronesValidateBeforeCall(lon, lat, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, maxCarNoParkDurationToPt, maxTaxiDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, carNoParkSpeed, taxiSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, directPathMode, partnerServices, additionalTimeAfterFirstSectionTaxi, additionalTimeBeforeLastSectionTaxi, criteria, minDuration, boundaryDuration, null, null);
        Type localVarReturnType = new TypeToken<GraphicalIsrochone1>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     *
     * @param lon The longitude of where the coord you want to query (required)
     * @param lat The latitude of where the coord you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param maxCarNoParkDurationToPt Maximal duration of car no park on public transport in second (optional)
     * @param maxTaxiDurationToPt Maximal duration of taxi on public transport in second, only available in distributed scenario (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carNoParkSpeed Driving speed without car park for the fallback sections. Speed unit must be in meter/second (optional)
     * @param taxiSpeed taxi speed speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;realtime&#39; - Use all realtime information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule. (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param directPathMode Force the direct-path modes.If this list is not empty, we only compute direct_path for modes in this listAnd filter all the direct_paths of modes in first_section_mode[] (optional)
     * @param partnerServices Expose only the partner type into the response. (optional)
     * @param additionalTimeAfterFirstSectionTaxi the additional time added to the taxi section, right after riding the taxi but before hopping on the public transit (optional)
     * @param additionalTimeBeforeLastSectionTaxi the additional time added to the taxi section, right before riding the taxi but after hopping off the public transit (optional)
     * @param criteria choose the criteria used to compute pt journeys, feature in beta  (optional)
     * @param minDuration Minimum travel duration (optional)
     * @param boundaryDuration To provide multiple duration parameters (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getCoverageLonLatIsochronesAsync(BigDecimal lon, BigDecimal lat, String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer minDuration, List<Integer> boundaryDuration, final ApiCallback<GraphicalIsrochone1> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCoverageLonLatIsochronesValidateBeforeCall(lon, lat, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, maxCarNoParkDurationToPt, maxTaxiDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, carNoParkSpeed, taxiSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, directPathMode, partnerServices, additionalTimeAfterFirstSectionTaxi, additionalTimeBeforeLastSectionTaxi, criteria, minDuration, boundaryDuration, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<GraphicalIsrochone1>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getCoverageRegionIsochrones
     * @param region The region you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param maxCarNoParkDurationToPt Maximal duration of car no park on public transport in second (optional)
     * @param maxTaxiDurationToPt Maximal duration of taxi on public transport in second, only available in distributed scenario (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carNoParkSpeed Driving speed without car park for the fallback sections. Speed unit must be in meter/second (optional)
     * @param taxiSpeed taxi speed speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;realtime&#39; - Use all realtime information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule. (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param directPathMode Force the direct-path modes.If this list is not empty, we only compute direct_path for modes in this listAnd filter all the direct_paths of modes in first_section_mode[] (optional)
     * @param partnerServices Expose only the partner type into the response. (optional)
     * @param additionalTimeAfterFirstSectionTaxi the additional time added to the taxi section, right after riding the taxi but before hopping on the public transit (optional)
     * @param additionalTimeBeforeLastSectionTaxi the additional time added to the taxi section, right before riding the taxi but after hopping off the public transit (optional)
     * @param criteria choose the criteria used to compute pt journeys, feature in beta  (optional)
     * @param minDuration Minimum travel duration (optional)
     * @param boundaryDuration To provide multiple duration parameters (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getCoverageRegionIsochronesCall(String region, String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer minDuration, List<Integer> boundaryDuration, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/coverage/{region}/isochrones"
            .replaceAll("\\{" + "region" + "\\}", apiClient.escapeString(region.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (from != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("from", from));
        if (to != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("to", to));
        if (datetime != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("datetime", datetime));
        if (datetimeRepresents != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("datetime_represents", datetimeRepresents));
        if (maxNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_nb_transfers", maxNbTransfers));
        if (minNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("min_nb_transfers", minNbTransfers));
        if (firstSectionMode != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "first_section_mode[]", firstSectionMode));
        if (lastSectionMode != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "last_section_mode[]", lastSectionMode));
        if (maxDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_duration_to_pt", maxDurationToPt));
        if (maxWalkingDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_walking_duration_to_pt", maxWalkingDurationToPt));
        if (maxBikeDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_bike_duration_to_pt", maxBikeDurationToPt));
        if (maxBssDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_bss_duration_to_pt", maxBssDurationToPt));
        if (maxCarDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_car_duration_to_pt", maxCarDurationToPt));
        if (maxRidesharingDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_ridesharing_duration_to_pt", maxRidesharingDurationToPt));
        if (maxCarNoParkDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_car_no_park_duration_to_pt", maxCarNoParkDurationToPt));
        if (maxTaxiDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_taxi_duration_to_pt", maxTaxiDurationToPt));
        if (walkingSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("walking_speed", walkingSpeed));
        if (bikeSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("bike_speed", bikeSpeed));
        if (bssSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("bss_speed", bssSpeed));
        if (carSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("car_speed", carSpeed));
        if (ridesharingSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("ridesharing_speed", ridesharingSpeed));
        if (carNoParkSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("car_no_park_speed", carNoParkSpeed));
        if (taxiSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("taxi_speed", taxiSpeed));
        if (forbiddenUris != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "forbidden_uris[]", forbiddenUris));
        if (allowedId != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "allowed_id[]", allowedId));
        if (disruptionActive != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("disruption_active", disruptionActive));
        if (dataFreshness != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("data_freshness", dataFreshness));
        if (maxDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_duration", maxDuration));
        if (wheelchair != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("wheelchair", wheelchair));
        if (travelerType != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("traveler_type", travelerType));
        if (directPath != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("direct_path", directPath));
        if (freeRadiusFrom != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("free_radius_from", freeRadiusFrom));
        if (freeRadiusTo != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("free_radius_to", freeRadiusTo));
        if (directPathMode != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "direct_path_mode[]", directPathMode));
        if (partnerServices != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "partner_services[]", partnerServices));
        if (additionalTimeAfterFirstSectionTaxi != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("additional_time_after_first_section_taxi", additionalTimeAfterFirstSectionTaxi));
        if (additionalTimeBeforeLastSectionTaxi != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("additional_time_before_last_section_taxi", additionalTimeBeforeLastSectionTaxi));
        if (criteria != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("criteria", criteria));
        if (minDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("min_duration", minDuration));
        if (boundaryDuration != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "boundary_duration[]", boundaryDuration));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        if (headers != null) {
            localVarHeaderParams.putAll(headers);
        }
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getCoverageRegionIsochronesValidateBeforeCall(String region, String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer minDuration, List<Integer> boundaryDuration, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // verify the required parameter 'region' is set
        if (region == null) {
            throw new ApiException("Missing the required parameter 'region' when calling getCoverageRegionIsochrones(Async)");
        }


        com.squareup.okhttp.Call call = getCoverageRegionIsochronesCall(region, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, maxCarNoParkDurationToPt, maxTaxiDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, carNoParkSpeed, taxiSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, directPathMode, partnerServices, additionalTimeAfterFirstSectionTaxi, additionalTimeBeforeLastSectionTaxi, criteria, minDuration, boundaryDuration, progressListener, progressRequestListener);
        return call;

    }

    /**
     *
     *
     * @param region The region you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param maxCarNoParkDurationToPt Maximal duration of car no park on public transport in second (optional)
     * @param maxTaxiDurationToPt Maximal duration of taxi on public transport in second, only available in distributed scenario (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carNoParkSpeed Driving speed without car park for the fallback sections. Speed unit must be in meter/second (optional)
     * @param taxiSpeed taxi speed speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;realtime&#39; - Use all realtime information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule. (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param directPathMode Force the direct-path modes.If this list is not empty, we only compute direct_path for modes in this listAnd filter all the direct_paths of modes in first_section_mode[] (optional)
     * @param partnerServices Expose only the partner type into the response. (optional)
     * @param additionalTimeAfterFirstSectionTaxi the additional time added to the taxi section, right after riding the taxi but before hopping on the public transit (optional)
     * @param additionalTimeBeforeLastSectionTaxi the additional time added to the taxi section, right before riding the taxi but after hopping off the public transit (optional)
     * @param criteria choose the criteria used to compute pt journeys, feature in beta  (optional)
     * @param minDuration Minimum travel duration (optional)
     * @param boundaryDuration To provide multiple duration parameters (optional)
     * @return GraphicalIsrochone1
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public GraphicalIsrochone1 getCoverageRegionIsochrones(String region, String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer minDuration, List<Integer> boundaryDuration) throws ApiException {
        ApiResponse<GraphicalIsrochone1> resp = getCoverageRegionIsochronesWithHttpInfo(region, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, maxCarNoParkDurationToPt, maxTaxiDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, carNoParkSpeed, taxiSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, directPathMode, partnerServices, additionalTimeAfterFirstSectionTaxi, additionalTimeBeforeLastSectionTaxi, criteria, minDuration, boundaryDuration);
        return resp.getData();
    }

    /**
     *
     *
     * @param region The region you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param maxCarNoParkDurationToPt Maximal duration of car no park on public transport in second (optional)
     * @param maxTaxiDurationToPt Maximal duration of taxi on public transport in second, only available in distributed scenario (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carNoParkSpeed Driving speed without car park for the fallback sections. Speed unit must be in meter/second (optional)
     * @param taxiSpeed taxi speed speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;realtime&#39; - Use all realtime information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule. (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param directPathMode Force the direct-path modes.If this list is not empty, we only compute direct_path for modes in this listAnd filter all the direct_paths of modes in first_section_mode[] (optional)
     * @param partnerServices Expose only the partner type into the response. (optional)
     * @param additionalTimeAfterFirstSectionTaxi the additional time added to the taxi section, right after riding the taxi but before hopping on the public transit (optional)
     * @param additionalTimeBeforeLastSectionTaxi the additional time added to the taxi section, right before riding the taxi but after hopping off the public transit (optional)
     * @param criteria choose the criteria used to compute pt journeys, feature in beta  (optional)
     * @param minDuration Minimum travel duration (optional)
     * @param boundaryDuration To provide multiple duration parameters (optional)
     * @return ApiResponse&lt;GraphicalIsrochone1&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<GraphicalIsrochone1> getCoverageRegionIsochronesWithHttpInfo(String region, String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer minDuration, List<Integer> boundaryDuration) throws ApiException {
        com.squareup.okhttp.Call call = getCoverageRegionIsochronesValidateBeforeCall(region, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, maxCarNoParkDurationToPt, maxTaxiDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, carNoParkSpeed, taxiSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, directPathMode, partnerServices, additionalTimeAfterFirstSectionTaxi, additionalTimeBeforeLastSectionTaxi, criteria, minDuration, boundaryDuration, null, null);
        Type localVarReturnType = new TypeToken<GraphicalIsrochone1>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     *
     * @param region The region you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param maxCarNoParkDurationToPt Maximal duration of car no park on public transport in second (optional)
     * @param maxTaxiDurationToPt Maximal duration of taxi on public transport in second, only available in distributed scenario (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carNoParkSpeed Driving speed without car park for the fallback sections. Speed unit must be in meter/second (optional)
     * @param taxiSpeed taxi speed speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;realtime&#39; - Use all realtime information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule. (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param directPathMode Force the direct-path modes.If this list is not empty, we only compute direct_path for modes in this listAnd filter all the direct_paths of modes in first_section_mode[] (optional)
     * @param partnerServices Expose only the partner type into the response. (optional)
     * @param additionalTimeAfterFirstSectionTaxi the additional time added to the taxi section, right after riding the taxi but before hopping on the public transit (optional)
     * @param additionalTimeBeforeLastSectionTaxi the additional time added to the taxi section, right before riding the taxi but after hopping off the public transit (optional)
     * @param criteria choose the criteria used to compute pt journeys, feature in beta  (optional)
     * @param minDuration Minimum travel duration (optional)
     * @param boundaryDuration To provide multiple duration parameters (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getCoverageRegionIsochronesAsync(String region, String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer minDuration, List<Integer> boundaryDuration, final ApiCallback<GraphicalIsrochone1> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCoverageRegionIsochronesValidateBeforeCall(region, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, maxCarNoParkDurationToPt, maxTaxiDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, carNoParkSpeed, taxiSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, directPathMode, partnerServices, additionalTimeAfterFirstSectionTaxi, additionalTimeBeforeLastSectionTaxi, criteria, minDuration, boundaryDuration, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<GraphicalIsrochone1>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
