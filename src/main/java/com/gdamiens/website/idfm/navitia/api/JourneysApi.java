/*
 * navitia
 *      navitia.io is the open API for building cool stuff with mobility data. It provides the following services      * journeys computation     * line schedules     * next departures     * exploration of public transport data / search places     * and sexy things such as isochrones      navitia is a HATEOAS API that returns JSON formated results
 *
 * OpenAPI spec version: v15.75.4
 * Contact: navitia@googlegroups.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.gdamiens.website.idfm.navitia.api;

import io.swagger.client.ApiCallback;
import io.swagger.client.ApiClient;
import io.swagger.client.ApiException;
import io.swagger.client.ApiResponse;
import io.swagger.client.Configuration;
import io.swagger.client.Pair;
import io.swagger.client.ProgressRequestBody;
import io.swagger.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.math.BigDecimal;
import io.swagger.client.model.Journeys;
import org.threeten.bp.OffsetDateTime;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class JourneysApi {
    private ApiClient apiClient;
    private Map<String, String> headers;

    public JourneysApi() {
        this(Configuration.getDefaultApiClient());
    }

    public JourneysApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public void setHeadersOverrides(Map<String, String> headers) {
        this.headers = headers;
    }

    /**
     * Build call for getCoverageLonLatJourneys
     * @param lon The longitude of where the coord you want to query (required)
     * @param lat The latitude of where the coord you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param maxCarNoParkDurationToPt Maximal duration of car no park on public transport in second (optional)
     * @param maxTaxiDurationToPt Maximal duration of taxi on public transport in second, only available in distributed scenario (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carNoParkSpeed Driving speed without car park for the fallback sections. Speed unit must be in meter/second (optional)
     * @param taxiSpeed taxi speed speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;realtime&#39; - Use all realtime information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule. (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param directPathMode Force the direct-path modes.If this list is not empty, we only compute direct_path for modes in this listAnd filter all the direct_paths of modes in first_section_mode[] (optional)
     * @param partnerServices Expose only the partner type into the response. (optional)
     * @param additionalTimeAfterFirstSectionTaxi the additional time added to the taxi section, right after riding the taxi but before hopping on the public transit (optional)
     * @param additionalTimeBeforeLastSectionTaxi the additional time added to the taxi section, right before riding the taxi but after hopping off the public transit (optional)
     * @param criteria choose the criteria used to compute pt journeys, feature in beta  (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param language Here, select a specific language for guidance instruction. list available: - nl-NL &#x3D; dutch - en-US | en-GB &#x3D; english - fr-FR &#x3D; french - de-DE &#x3D; german - hi-IN &#x3D; hindi - it-IT &#x3D; italian - ja-JP &#x3D; japanese - pt-PT &#x3D; portuguese - ru-RU &#x3D; russian - es-ES &#x3D; spanish  (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @param maxRidesharingDirectPathDuration limit duration of direct path in ridesharing, used ONLY in distributed scenario (optional)
     * @param maxBssDirectPathDuration limit duration of direct path in bss, used ONLY in distributed scenario (optional)
     * @param maxWalkingDirectPathDuration limit duration of direct path in walking, used ONLY in distributed scenario (optional)
     * @param maxCarNoParkDirectPathDuration limit duration of direct path in car_no_park, used ONLY in distributed scenario (optional)
     * @param maxBikeDirectPathDuration limit duration of direct path in bike, used ONLY in distributed scenario (optional)
     * @param maxCarDirectPathDuration limit duration of direct path in car, used ONLY in distributed scenario (optional)
     * @param maxTaxiDirectPathDuration limit duration of direct path in taxi, used ONLY in distributed scenario (optional)
     * @param depth The depth of your object (optional, default to 1)
     * @param maxWaitingDuration A journey containing a waiting section with a duration greater or equal to  max_waiting_duration will be discarded. Units : seconds. Must be &gt; 0. Default value : 4h (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getCoverageLonLatJourneysCall(BigDecimal lon, BigDecimal lat, String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, String language, Boolean equipmentDetails, Integer maxRidesharingDirectPathDuration, Integer maxBssDirectPathDuration, Integer maxWalkingDirectPathDuration, Integer maxCarNoParkDirectPathDuration, Integer maxBikeDirectPathDuration, Integer maxCarDirectPathDuration, Integer maxTaxiDirectPathDuration, Integer depth, Integer maxWaitingDuration, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/coverage/{lon};{lat}/journeys"
            .replaceAll("\\{" + "lon" + "\\}", apiClient.escapeString(lon.toString()))
            .replaceAll("\\{" + "lat" + "\\}", apiClient.escapeString(lat.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (from != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("from", from));
        if (to != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("to", to));
        if (datetime != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("datetime", datetime));
        if (datetimeRepresents != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("datetime_represents", datetimeRepresents));
        if (maxNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_nb_transfers", maxNbTransfers));
        if (minNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("min_nb_transfers", minNbTransfers));
        if (firstSectionMode != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "first_section_mode[]", firstSectionMode));
        if (lastSectionMode != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "last_section_mode[]", lastSectionMode));
        if (maxDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_duration_to_pt", maxDurationToPt));
        if (maxWalkingDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_walking_duration_to_pt", maxWalkingDurationToPt));
        if (maxBikeDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_bike_duration_to_pt", maxBikeDurationToPt));
        if (maxBssDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_bss_duration_to_pt", maxBssDurationToPt));
        if (maxCarDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_car_duration_to_pt", maxCarDurationToPt));
        if (maxRidesharingDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_ridesharing_duration_to_pt", maxRidesharingDurationToPt));
        if (maxCarNoParkDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_car_no_park_duration_to_pt", maxCarNoParkDurationToPt));
        if (maxTaxiDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_taxi_duration_to_pt", maxTaxiDurationToPt));
        if (walkingSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("walking_speed", walkingSpeed));
        if (bikeSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("bike_speed", bikeSpeed));
        if (bssSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("bss_speed", bssSpeed));
        if (carSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("car_speed", carSpeed));
        if (ridesharingSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("ridesharing_speed", ridesharingSpeed));
        if (carNoParkSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("car_no_park_speed", carNoParkSpeed));
        if (taxiSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("taxi_speed", taxiSpeed));
        if (forbiddenUris != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "forbidden_uris[]", forbiddenUris));
        if (allowedId != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "allowed_id[]", allowedId));
        if (disruptionActive != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("disruption_active", disruptionActive));
        if (dataFreshness != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("data_freshness", dataFreshness));
        if (maxDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_duration", maxDuration));
        if (wheelchair != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("wheelchair", wheelchair));
        if (travelerType != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("traveler_type", travelerType));
        if (directPath != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("direct_path", directPath));
        if (freeRadiusFrom != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("free_radius_from", freeRadiusFrom));
        if (freeRadiusTo != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("free_radius_to", freeRadiusTo));
        if (directPathMode != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "direct_path_mode[]", directPathMode));
        if (partnerServices != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "partner_services[]", partnerServices));
        if (additionalTimeAfterFirstSectionTaxi != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("additional_time_after_first_section_taxi", additionalTimeAfterFirstSectionTaxi));
        if (additionalTimeBeforeLastSectionTaxi != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("additional_time_before_last_section_taxi", additionalTimeBeforeLastSectionTaxi));
        if (criteria != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("criteria", criteria));
        if (count != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("count", count));
        if (isJourneySchedules != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("is_journey_schedules", isJourneySchedules));
        if (minNbJourneys != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("min_nb_journeys", minNbJourneys));
        if (maxNbJourneys != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_nb_journeys", maxNbJourneys));
        if (bssStands != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("bss_stands", bssStands));
        if (addPoiInfos != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "add_poi_infos[]", addPoiInfos));
        if (timeframeDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("timeframe_duration", timeframeDuration));
        if (language != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("language", language));
        if (equipmentDetails != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("equipment_details", equipmentDetails));
        if (maxRidesharingDirectPathDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_ridesharing_direct_path_duration", maxRidesharingDirectPathDuration));
        if (maxBssDirectPathDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_bss_direct_path_duration", maxBssDirectPathDuration));
        if (maxWalkingDirectPathDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_walking_direct_path_duration", maxWalkingDirectPathDuration));
        if (maxCarNoParkDirectPathDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_car_no_park_direct_path_duration", maxCarNoParkDirectPathDuration));
        if (maxBikeDirectPathDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_bike_direct_path_duration", maxBikeDirectPathDuration));
        if (maxCarDirectPathDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_car_direct_path_duration", maxCarDirectPathDuration));
        if (maxTaxiDirectPathDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_taxi_direct_path_duration", maxTaxiDirectPathDuration));
        if (depth != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("depth", depth));
        if (maxWaitingDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_waiting_duration", maxWaitingDuration));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        if (headers != null) {
            localVarHeaderParams.putAll(headers);
        }
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getCoverageLonLatJourneysValidateBeforeCall(BigDecimal lon, BigDecimal lat, String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, String language, Boolean equipmentDetails, Integer maxRidesharingDirectPathDuration, Integer maxBssDirectPathDuration, Integer maxWalkingDirectPathDuration, Integer maxCarNoParkDirectPathDuration, Integer maxBikeDirectPathDuration, Integer maxCarDirectPathDuration, Integer maxTaxiDirectPathDuration, Integer depth, Integer maxWaitingDuration, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // verify the required parameter 'lon' is set
        if (lon == null) {
            throw new ApiException("Missing the required parameter 'lon' when calling getCoverageLonLatJourneys(Async)");
        }

        // verify the required parameter 'lat' is set
        if (lat == null) {
            throw new ApiException("Missing the required parameter 'lat' when calling getCoverageLonLatJourneys(Async)");
        }


        com.squareup.okhttp.Call call = getCoverageLonLatJourneysCall(lon, lat, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, maxCarNoParkDurationToPt, maxTaxiDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, carNoParkSpeed, taxiSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, directPathMode, partnerServices, additionalTimeAfterFirstSectionTaxi, additionalTimeBeforeLastSectionTaxi, criteria, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, language, equipmentDetails, maxRidesharingDirectPathDuration, maxBssDirectPathDuration, maxWalkingDirectPathDuration, maxCarNoParkDirectPathDuration, maxBikeDirectPathDuration, maxCarDirectPathDuration, maxTaxiDirectPathDuration, depth, maxWaitingDuration, progressListener, progressRequestListener);
        return call;

    }

    /**
     *
     *
     * @param lon The longitude of where the coord you want to query (required)
     * @param lat The latitude of where the coord you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param maxCarNoParkDurationToPt Maximal duration of car no park on public transport in second (optional)
     * @param maxTaxiDurationToPt Maximal duration of taxi on public transport in second, only available in distributed scenario (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carNoParkSpeed Driving speed without car park for the fallback sections. Speed unit must be in meter/second (optional)
     * @param taxiSpeed taxi speed speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;realtime&#39; - Use all realtime information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule. (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param directPathMode Force the direct-path modes.If this list is not empty, we only compute direct_path for modes in this listAnd filter all the direct_paths of modes in first_section_mode[] (optional)
     * @param partnerServices Expose only the partner type into the response. (optional)
     * @param additionalTimeAfterFirstSectionTaxi the additional time added to the taxi section, right after riding the taxi but before hopping on the public transit (optional)
     * @param additionalTimeBeforeLastSectionTaxi the additional time added to the taxi section, right before riding the taxi but after hopping off the public transit (optional)
     * @param criteria choose the criteria used to compute pt journeys, feature in beta  (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param language Here, select a specific language for guidance instruction. list available: - nl-NL &#x3D; dutch - en-US | en-GB &#x3D; english - fr-FR &#x3D; french - de-DE &#x3D; german - hi-IN &#x3D; hindi - it-IT &#x3D; italian - ja-JP &#x3D; japanese - pt-PT &#x3D; portuguese - ru-RU &#x3D; russian - es-ES &#x3D; spanish  (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @param maxRidesharingDirectPathDuration limit duration of direct path in ridesharing, used ONLY in distributed scenario (optional)
     * @param maxBssDirectPathDuration limit duration of direct path in bss, used ONLY in distributed scenario (optional)
     * @param maxWalkingDirectPathDuration limit duration of direct path in walking, used ONLY in distributed scenario (optional)
     * @param maxCarNoParkDirectPathDuration limit duration of direct path in car_no_park, used ONLY in distributed scenario (optional)
     * @param maxBikeDirectPathDuration limit duration of direct path in bike, used ONLY in distributed scenario (optional)
     * @param maxCarDirectPathDuration limit duration of direct path in car, used ONLY in distributed scenario (optional)
     * @param maxTaxiDirectPathDuration limit duration of direct path in taxi, used ONLY in distributed scenario (optional)
     * @param depth The depth of your object (optional, default to 1)
     * @param maxWaitingDuration A journey containing a waiting section with a duration greater or equal to  max_waiting_duration will be discarded. Units : seconds. Must be &gt; 0. Default value : 4h (optional)
     * @return Journeys
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public Journeys getCoverageLonLatJourneys(BigDecimal lon, BigDecimal lat, String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, String language, Boolean equipmentDetails, Integer maxRidesharingDirectPathDuration, Integer maxBssDirectPathDuration, Integer maxWalkingDirectPathDuration, Integer maxCarNoParkDirectPathDuration, Integer maxBikeDirectPathDuration, Integer maxCarDirectPathDuration, Integer maxTaxiDirectPathDuration, Integer depth, Integer maxWaitingDuration) throws ApiException {
        ApiResponse<Journeys> resp = getCoverageLonLatJourneysWithHttpInfo(lon, lat, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, maxCarNoParkDurationToPt, maxTaxiDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, carNoParkSpeed, taxiSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, directPathMode, partnerServices, additionalTimeAfterFirstSectionTaxi, additionalTimeBeforeLastSectionTaxi, criteria, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, language, equipmentDetails, maxRidesharingDirectPathDuration, maxBssDirectPathDuration, maxWalkingDirectPathDuration, maxCarNoParkDirectPathDuration, maxBikeDirectPathDuration, maxCarDirectPathDuration, maxTaxiDirectPathDuration, depth, maxWaitingDuration);
        return resp.getData();
    }

    /**
     *
     *
     * @param lon The longitude of where the coord you want to query (required)
     * @param lat The latitude of where the coord you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param maxCarNoParkDurationToPt Maximal duration of car no park on public transport in second (optional)
     * @param maxTaxiDurationToPt Maximal duration of taxi on public transport in second, only available in distributed scenario (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carNoParkSpeed Driving speed without car park for the fallback sections. Speed unit must be in meter/second (optional)
     * @param taxiSpeed taxi speed speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;realtime&#39; - Use all realtime information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule. (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param directPathMode Force the direct-path modes.If this list is not empty, we only compute direct_path for modes in this listAnd filter all the direct_paths of modes in first_section_mode[] (optional)
     * @param partnerServices Expose only the partner type into the response. (optional)
     * @param additionalTimeAfterFirstSectionTaxi the additional time added to the taxi section, right after riding the taxi but before hopping on the public transit (optional)
     * @param additionalTimeBeforeLastSectionTaxi the additional time added to the taxi section, right before riding the taxi but after hopping off the public transit (optional)
     * @param criteria choose the criteria used to compute pt journeys, feature in beta  (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param language Here, select a specific language for guidance instruction. list available: - nl-NL &#x3D; dutch - en-US | en-GB &#x3D; english - fr-FR &#x3D; french - de-DE &#x3D; german - hi-IN &#x3D; hindi - it-IT &#x3D; italian - ja-JP &#x3D; japanese - pt-PT &#x3D; portuguese - ru-RU &#x3D; russian - es-ES &#x3D; spanish  (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @param maxRidesharingDirectPathDuration limit duration of direct path in ridesharing, used ONLY in distributed scenario (optional)
     * @param maxBssDirectPathDuration limit duration of direct path in bss, used ONLY in distributed scenario (optional)
     * @param maxWalkingDirectPathDuration limit duration of direct path in walking, used ONLY in distributed scenario (optional)
     * @param maxCarNoParkDirectPathDuration limit duration of direct path in car_no_park, used ONLY in distributed scenario (optional)
     * @param maxBikeDirectPathDuration limit duration of direct path in bike, used ONLY in distributed scenario (optional)
     * @param maxCarDirectPathDuration limit duration of direct path in car, used ONLY in distributed scenario (optional)
     * @param maxTaxiDirectPathDuration limit duration of direct path in taxi, used ONLY in distributed scenario (optional)
     * @param depth The depth of your object (optional, default to 1)
     * @param maxWaitingDuration A journey containing a waiting section with a duration greater or equal to  max_waiting_duration will be discarded. Units : seconds. Must be &gt; 0. Default value : 4h (optional)
     * @return ApiResponse&lt;Journeys&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Journeys> getCoverageLonLatJourneysWithHttpInfo(BigDecimal lon, BigDecimal lat, String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, String language, Boolean equipmentDetails, Integer maxRidesharingDirectPathDuration, Integer maxBssDirectPathDuration, Integer maxWalkingDirectPathDuration, Integer maxCarNoParkDirectPathDuration, Integer maxBikeDirectPathDuration, Integer maxCarDirectPathDuration, Integer maxTaxiDirectPathDuration, Integer depth, Integer maxWaitingDuration) throws ApiException {
        com.squareup.okhttp.Call call = getCoverageLonLatJourneysValidateBeforeCall(lon, lat, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, maxCarNoParkDurationToPt, maxTaxiDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, carNoParkSpeed, taxiSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, directPathMode, partnerServices, additionalTimeAfterFirstSectionTaxi, additionalTimeBeforeLastSectionTaxi, criteria, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, language, equipmentDetails, maxRidesharingDirectPathDuration, maxBssDirectPathDuration, maxWalkingDirectPathDuration, maxCarNoParkDirectPathDuration, maxBikeDirectPathDuration, maxCarDirectPathDuration, maxTaxiDirectPathDuration, depth, maxWaitingDuration, null, null);
        Type localVarReturnType = new TypeToken<Journeys>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     *
     * @param lon The longitude of where the coord you want to query (required)
     * @param lat The latitude of where the coord you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param maxCarNoParkDurationToPt Maximal duration of car no park on public transport in second (optional)
     * @param maxTaxiDurationToPt Maximal duration of taxi on public transport in second, only available in distributed scenario (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carNoParkSpeed Driving speed without car park for the fallback sections. Speed unit must be in meter/second (optional)
     * @param taxiSpeed taxi speed speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;realtime&#39; - Use all realtime information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule. (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param directPathMode Force the direct-path modes.If this list is not empty, we only compute direct_path for modes in this listAnd filter all the direct_paths of modes in first_section_mode[] (optional)
     * @param partnerServices Expose only the partner type into the response. (optional)
     * @param additionalTimeAfterFirstSectionTaxi the additional time added to the taxi section, right after riding the taxi but before hopping on the public transit (optional)
     * @param additionalTimeBeforeLastSectionTaxi the additional time added to the taxi section, right before riding the taxi but after hopping off the public transit (optional)
     * @param criteria choose the criteria used to compute pt journeys, feature in beta  (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param language Here, select a specific language for guidance instruction. list available: - nl-NL &#x3D; dutch - en-US | en-GB &#x3D; english - fr-FR &#x3D; french - de-DE &#x3D; german - hi-IN &#x3D; hindi - it-IT &#x3D; italian - ja-JP &#x3D; japanese - pt-PT &#x3D; portuguese - ru-RU &#x3D; russian - es-ES &#x3D; spanish  (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @param maxRidesharingDirectPathDuration limit duration of direct path in ridesharing, used ONLY in distributed scenario (optional)
     * @param maxBssDirectPathDuration limit duration of direct path in bss, used ONLY in distributed scenario (optional)
     * @param maxWalkingDirectPathDuration limit duration of direct path in walking, used ONLY in distributed scenario (optional)
     * @param maxCarNoParkDirectPathDuration limit duration of direct path in car_no_park, used ONLY in distributed scenario (optional)
     * @param maxBikeDirectPathDuration limit duration of direct path in bike, used ONLY in distributed scenario (optional)
     * @param maxCarDirectPathDuration limit duration of direct path in car, used ONLY in distributed scenario (optional)
     * @param maxTaxiDirectPathDuration limit duration of direct path in taxi, used ONLY in distributed scenario (optional)
     * @param depth The depth of your object (optional, default to 1)
     * @param maxWaitingDuration A journey containing a waiting section with a duration greater or equal to  max_waiting_duration will be discarded. Units : seconds. Must be &gt; 0. Default value : 4h (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getCoverageLonLatJourneysAsync(BigDecimal lon, BigDecimal lat, String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, String language, Boolean equipmentDetails, Integer maxRidesharingDirectPathDuration, Integer maxBssDirectPathDuration, Integer maxWalkingDirectPathDuration, Integer maxCarNoParkDirectPathDuration, Integer maxBikeDirectPathDuration, Integer maxCarDirectPathDuration, Integer maxTaxiDirectPathDuration, Integer depth, Integer maxWaitingDuration, final ApiCallback<Journeys> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCoverageLonLatJourneysValidateBeforeCall(lon, lat, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, maxCarNoParkDurationToPt, maxTaxiDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, carNoParkSpeed, taxiSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, directPathMode, partnerServices, additionalTimeAfterFirstSectionTaxi, additionalTimeBeforeLastSectionTaxi, criteria, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, language, equipmentDetails, maxRidesharingDirectPathDuration, maxBssDirectPathDuration, maxWalkingDirectPathDuration, maxCarNoParkDirectPathDuration, maxBikeDirectPathDuration, maxCarDirectPathDuration, maxTaxiDirectPathDuration, depth, maxWaitingDuration, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Journeys>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getCoverageRegionJourneys
     * @param region The region you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param maxCarNoParkDurationToPt Maximal duration of car no park on public transport in second (optional)
     * @param maxTaxiDurationToPt Maximal duration of taxi on public transport in second, only available in distributed scenario (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carNoParkSpeed Driving speed without car park for the fallback sections. Speed unit must be in meter/second (optional)
     * @param taxiSpeed taxi speed speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;realtime&#39; - Use all realtime information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule. (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param directPathMode Force the direct-path modes.If this list is not empty, we only compute direct_path for modes in this listAnd filter all the direct_paths of modes in first_section_mode[] (optional)
     * @param partnerServices Expose only the partner type into the response. (optional)
     * @param additionalTimeAfterFirstSectionTaxi the additional time added to the taxi section, right after riding the taxi but before hopping on the public transit (optional)
     * @param additionalTimeBeforeLastSectionTaxi the additional time added to the taxi section, right before riding the taxi but after hopping off the public transit (optional)
     * @param criteria choose the criteria used to compute pt journeys, feature in beta  (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param language Here, select a specific language for guidance instruction. list available: - nl-NL &#x3D; dutch - en-US | en-GB &#x3D; english - fr-FR &#x3D; french - de-DE &#x3D; german - hi-IN &#x3D; hindi - it-IT &#x3D; italian - ja-JP &#x3D; japanese - pt-PT &#x3D; portuguese - ru-RU &#x3D; russian - es-ES &#x3D; spanish  (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @param maxRidesharingDirectPathDuration limit duration of direct path in ridesharing, used ONLY in distributed scenario (optional)
     * @param maxBssDirectPathDuration limit duration of direct path in bss, used ONLY in distributed scenario (optional)
     * @param maxWalkingDirectPathDuration limit duration of direct path in walking, used ONLY in distributed scenario (optional)
     * @param maxCarNoParkDirectPathDuration limit duration of direct path in car_no_park, used ONLY in distributed scenario (optional)
     * @param maxBikeDirectPathDuration limit duration of direct path in bike, used ONLY in distributed scenario (optional)
     * @param maxCarDirectPathDuration limit duration of direct path in car, used ONLY in distributed scenario (optional)
     * @param maxTaxiDirectPathDuration limit duration of direct path in taxi, used ONLY in distributed scenario (optional)
     * @param depth The depth of your object (optional, default to 1)
     * @param maxWaitingDuration A journey containing a waiting section with a duration greater or equal to  max_waiting_duration will be discarded. Units : seconds. Must be &gt; 0. Default value : 4h (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getCoverageRegionJourneysCall(String region, String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, String language, Boolean equipmentDetails, Integer maxRidesharingDirectPathDuration, Integer maxBssDirectPathDuration, Integer maxWalkingDirectPathDuration, Integer maxCarNoParkDirectPathDuration, Integer maxBikeDirectPathDuration, Integer maxCarDirectPathDuration, Integer maxTaxiDirectPathDuration, Integer depth, Integer maxWaitingDuration, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/coverage/{region}/journeys"
            .replaceAll("\\{" + "region" + "\\}", apiClient.escapeString(region.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (from != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("from", from));
        if (to != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("to", to));
        if (datetime != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("datetime", datetime));
        if (datetimeRepresents != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("datetime_represents", datetimeRepresents));
        if (maxNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_nb_transfers", maxNbTransfers));
        if (minNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("min_nb_transfers", minNbTransfers));
        if (firstSectionMode != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "first_section_mode[]", firstSectionMode));
        if (lastSectionMode != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "last_section_mode[]", lastSectionMode));
        if (maxDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_duration_to_pt", maxDurationToPt));
        if (maxWalkingDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_walking_duration_to_pt", maxWalkingDurationToPt));
        if (maxBikeDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_bike_duration_to_pt", maxBikeDurationToPt));
        if (maxBssDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_bss_duration_to_pt", maxBssDurationToPt));
        if (maxCarDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_car_duration_to_pt", maxCarDurationToPt));
        if (maxRidesharingDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_ridesharing_duration_to_pt", maxRidesharingDurationToPt));
        if (maxCarNoParkDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_car_no_park_duration_to_pt", maxCarNoParkDurationToPt));
        if (maxTaxiDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_taxi_duration_to_pt", maxTaxiDurationToPt));
        if (walkingSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("walking_speed", walkingSpeed));
        if (bikeSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("bike_speed", bikeSpeed));
        if (bssSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("bss_speed", bssSpeed));
        if (carSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("car_speed", carSpeed));
        if (ridesharingSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("ridesharing_speed", ridesharingSpeed));
        if (carNoParkSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("car_no_park_speed", carNoParkSpeed));
        if (taxiSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("taxi_speed", taxiSpeed));
        if (forbiddenUris != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "forbidden_uris[]", forbiddenUris));
        if (allowedId != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "allowed_id[]", allowedId));
        if (disruptionActive != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("disruption_active", disruptionActive));
        if (dataFreshness != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("data_freshness", dataFreshness));
        if (maxDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_duration", maxDuration));
        if (wheelchair != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("wheelchair", wheelchair));
        if (travelerType != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("traveler_type", travelerType));
        if (directPath != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("direct_path", directPath));
        if (freeRadiusFrom != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("free_radius_from", freeRadiusFrom));
        if (freeRadiusTo != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("free_radius_to", freeRadiusTo));
        if (directPathMode != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "direct_path_mode[]", directPathMode));
        if (partnerServices != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "partner_services[]", partnerServices));
        if (additionalTimeAfterFirstSectionTaxi != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("additional_time_after_first_section_taxi", additionalTimeAfterFirstSectionTaxi));
        if (additionalTimeBeforeLastSectionTaxi != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("additional_time_before_last_section_taxi", additionalTimeBeforeLastSectionTaxi));
        if (criteria != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("criteria", criteria));
        if (count != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("count", count));
        if (isJourneySchedules != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("is_journey_schedules", isJourneySchedules));
        if (minNbJourneys != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("min_nb_journeys", minNbJourneys));
        if (maxNbJourneys != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_nb_journeys", maxNbJourneys));
        if (bssStands != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("bss_stands", bssStands));
        if (addPoiInfos != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "add_poi_infos[]", addPoiInfos));
        if (timeframeDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("timeframe_duration", timeframeDuration));
        if (language != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("language", language));
        if (equipmentDetails != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("equipment_details", equipmentDetails));
        if (maxRidesharingDirectPathDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_ridesharing_direct_path_duration", maxRidesharingDirectPathDuration));
        if (maxBssDirectPathDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_bss_direct_path_duration", maxBssDirectPathDuration));
        if (maxWalkingDirectPathDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_walking_direct_path_duration", maxWalkingDirectPathDuration));
        if (maxCarNoParkDirectPathDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_car_no_park_direct_path_duration", maxCarNoParkDirectPathDuration));
        if (maxBikeDirectPathDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_bike_direct_path_duration", maxBikeDirectPathDuration));
        if (maxCarDirectPathDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_car_direct_path_duration", maxCarDirectPathDuration));
        if (maxTaxiDirectPathDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_taxi_direct_path_duration", maxTaxiDirectPathDuration));
        if (depth != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("depth", depth));
        if (maxWaitingDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_waiting_duration", maxWaitingDuration));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        if (headers != null) {
            localVarHeaderParams.putAll(headers);
        }
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getCoverageRegionJourneysValidateBeforeCall(String region, String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, String language, Boolean equipmentDetails, Integer maxRidesharingDirectPathDuration, Integer maxBssDirectPathDuration, Integer maxWalkingDirectPathDuration, Integer maxCarNoParkDirectPathDuration, Integer maxBikeDirectPathDuration, Integer maxCarDirectPathDuration, Integer maxTaxiDirectPathDuration, Integer depth, Integer maxWaitingDuration, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {

        // verify the required parameter 'region' is set
        if (region == null) {
            throw new ApiException("Missing the required parameter 'region' when calling getCoverageRegionJourneys(Async)");
        }


        com.squareup.okhttp.Call call = getCoverageRegionJourneysCall(region, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, maxCarNoParkDurationToPt, maxTaxiDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, carNoParkSpeed, taxiSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, directPathMode, partnerServices, additionalTimeAfterFirstSectionTaxi, additionalTimeBeforeLastSectionTaxi, criteria, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, language, equipmentDetails, maxRidesharingDirectPathDuration, maxBssDirectPathDuration, maxWalkingDirectPathDuration, maxCarNoParkDirectPathDuration, maxBikeDirectPathDuration, maxCarDirectPathDuration, maxTaxiDirectPathDuration, depth, maxWaitingDuration, progressListener, progressRequestListener);
        return call;

    }

    /**
     *
     *
     * @param region The region you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param maxCarNoParkDurationToPt Maximal duration of car no park on public transport in second (optional)
     * @param maxTaxiDurationToPt Maximal duration of taxi on public transport in second, only available in distributed scenario (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carNoParkSpeed Driving speed without car park for the fallback sections. Speed unit must be in meter/second (optional)
     * @param taxiSpeed taxi speed speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;realtime&#39; - Use all realtime information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule. (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param directPathMode Force the direct-path modes.If this list is not empty, we only compute direct_path for modes in this listAnd filter all the direct_paths of modes in first_section_mode[] (optional)
     * @param partnerServices Expose only the partner type into the response. (optional)
     * @param additionalTimeAfterFirstSectionTaxi the additional time added to the taxi section, right after riding the taxi but before hopping on the public transit (optional)
     * @param additionalTimeBeforeLastSectionTaxi the additional time added to the taxi section, right before riding the taxi but after hopping off the public transit (optional)
     * @param criteria choose the criteria used to compute pt journeys, feature in beta  (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param language Here, select a specific language for guidance instruction. list available: - nl-NL &#x3D; dutch - en-US | en-GB &#x3D; english - fr-FR &#x3D; french - de-DE &#x3D; german - hi-IN &#x3D; hindi - it-IT &#x3D; italian - ja-JP &#x3D; japanese - pt-PT &#x3D; portuguese - ru-RU &#x3D; russian - es-ES &#x3D; spanish  (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @param maxRidesharingDirectPathDuration limit duration of direct path in ridesharing, used ONLY in distributed scenario (optional)
     * @param maxBssDirectPathDuration limit duration of direct path in bss, used ONLY in distributed scenario (optional)
     * @param maxWalkingDirectPathDuration limit duration of direct path in walking, used ONLY in distributed scenario (optional)
     * @param maxCarNoParkDirectPathDuration limit duration of direct path in car_no_park, used ONLY in distributed scenario (optional)
     * @param maxBikeDirectPathDuration limit duration of direct path in bike, used ONLY in distributed scenario (optional)
     * @param maxCarDirectPathDuration limit duration of direct path in car, used ONLY in distributed scenario (optional)
     * @param maxTaxiDirectPathDuration limit duration of direct path in taxi, used ONLY in distributed scenario (optional)
     * @param depth The depth of your object (optional, default to 1)
     * @param maxWaitingDuration A journey containing a waiting section with a duration greater or equal to  max_waiting_duration will be discarded. Units : seconds. Must be &gt; 0. Default value : 4h (optional)
     * @return Journeys
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public Journeys getCoverageRegionJourneys(String region, String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, String language, Boolean equipmentDetails, Integer maxRidesharingDirectPathDuration, Integer maxBssDirectPathDuration, Integer maxWalkingDirectPathDuration, Integer maxCarNoParkDirectPathDuration, Integer maxBikeDirectPathDuration, Integer maxCarDirectPathDuration, Integer maxTaxiDirectPathDuration, Integer depth, Integer maxWaitingDuration) throws ApiException {
        ApiResponse<Journeys> resp = getCoverageRegionJourneysWithHttpInfo(region, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, maxCarNoParkDurationToPt, maxTaxiDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, carNoParkSpeed, taxiSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, directPathMode, partnerServices, additionalTimeAfterFirstSectionTaxi, additionalTimeBeforeLastSectionTaxi, criteria, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, language, equipmentDetails, maxRidesharingDirectPathDuration, maxBssDirectPathDuration, maxWalkingDirectPathDuration, maxCarNoParkDirectPathDuration, maxBikeDirectPathDuration, maxCarDirectPathDuration, maxTaxiDirectPathDuration, depth, maxWaitingDuration);
        return resp.getData();
    }

    /**
     *
     *
     * @param region The region you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param maxCarNoParkDurationToPt Maximal duration of car no park on public transport in second (optional)
     * @param maxTaxiDurationToPt Maximal duration of taxi on public transport in second, only available in distributed scenario (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carNoParkSpeed Driving speed without car park for the fallback sections. Speed unit must be in meter/second (optional)
     * @param taxiSpeed taxi speed speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;realtime&#39; - Use all realtime information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule. (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param directPathMode Force the direct-path modes.If this list is not empty, we only compute direct_path for modes in this listAnd filter all the direct_paths of modes in first_section_mode[] (optional)
     * @param partnerServices Expose only the partner type into the response. (optional)
     * @param additionalTimeAfterFirstSectionTaxi the additional time added to the taxi section, right after riding the taxi but before hopping on the public transit (optional)
     * @param additionalTimeBeforeLastSectionTaxi the additional time added to the taxi section, right before riding the taxi but after hopping off the public transit (optional)
     * @param criteria choose the criteria used to compute pt journeys, feature in beta  (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param language Here, select a specific language for guidance instruction. list available: - nl-NL &#x3D; dutch - en-US | en-GB &#x3D; english - fr-FR &#x3D; french - de-DE &#x3D; german - hi-IN &#x3D; hindi - it-IT &#x3D; italian - ja-JP &#x3D; japanese - pt-PT &#x3D; portuguese - ru-RU &#x3D; russian - es-ES &#x3D; spanish  (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @param maxRidesharingDirectPathDuration limit duration of direct path in ridesharing, used ONLY in distributed scenario (optional)
     * @param maxBssDirectPathDuration limit duration of direct path in bss, used ONLY in distributed scenario (optional)
     * @param maxWalkingDirectPathDuration limit duration of direct path in walking, used ONLY in distributed scenario (optional)
     * @param maxCarNoParkDirectPathDuration limit duration of direct path in car_no_park, used ONLY in distributed scenario (optional)
     * @param maxBikeDirectPathDuration limit duration of direct path in bike, used ONLY in distributed scenario (optional)
     * @param maxCarDirectPathDuration limit duration of direct path in car, used ONLY in distributed scenario (optional)
     * @param maxTaxiDirectPathDuration limit duration of direct path in taxi, used ONLY in distributed scenario (optional)
     * @param depth The depth of your object (optional, default to 1)
     * @param maxWaitingDuration A journey containing a waiting section with a duration greater or equal to  max_waiting_duration will be discarded. Units : seconds. Must be &gt; 0. Default value : 4h (optional)
     * @return ApiResponse&lt;Journeys&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Journeys> getCoverageRegionJourneysWithHttpInfo(String region, String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, String language, Boolean equipmentDetails, Integer maxRidesharingDirectPathDuration, Integer maxBssDirectPathDuration, Integer maxWalkingDirectPathDuration, Integer maxCarNoParkDirectPathDuration, Integer maxBikeDirectPathDuration, Integer maxCarDirectPathDuration, Integer maxTaxiDirectPathDuration, Integer depth, Integer maxWaitingDuration) throws ApiException {
        com.squareup.okhttp.Call call = getCoverageRegionJourneysValidateBeforeCall(region, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, maxCarNoParkDurationToPt, maxTaxiDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, carNoParkSpeed, taxiSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, directPathMode, partnerServices, additionalTimeAfterFirstSectionTaxi, additionalTimeBeforeLastSectionTaxi, criteria, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, language, equipmentDetails, maxRidesharingDirectPathDuration, maxBssDirectPathDuration, maxWalkingDirectPathDuration, maxCarNoParkDirectPathDuration, maxBikeDirectPathDuration, maxCarDirectPathDuration, maxTaxiDirectPathDuration, depth, maxWaitingDuration, null, null);
        Type localVarReturnType = new TypeToken<Journeys>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     *
     * @param region The region you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param maxCarNoParkDurationToPt Maximal duration of car no park on public transport in second (optional)
     * @param maxTaxiDurationToPt Maximal duration of taxi on public transport in second, only available in distributed scenario (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carNoParkSpeed Driving speed without car park for the fallback sections. Speed unit must be in meter/second (optional)
     * @param taxiSpeed taxi speed speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;realtime&#39; - Use all realtime information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule. (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param directPathMode Force the direct-path modes.If this list is not empty, we only compute direct_path for modes in this listAnd filter all the direct_paths of modes in first_section_mode[] (optional)
     * @param partnerServices Expose only the partner type into the response. (optional)
     * @param additionalTimeAfterFirstSectionTaxi the additional time added to the taxi section, right after riding the taxi but before hopping on the public transit (optional)
     * @param additionalTimeBeforeLastSectionTaxi the additional time added to the taxi section, right before riding the taxi but after hopping off the public transit (optional)
     * @param criteria choose the criteria used to compute pt journeys, feature in beta  (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param language Here, select a specific language for guidance instruction. list available: - nl-NL &#x3D; dutch - en-US | en-GB &#x3D; english - fr-FR &#x3D; french - de-DE &#x3D; german - hi-IN &#x3D; hindi - it-IT &#x3D; italian - ja-JP &#x3D; japanese - pt-PT &#x3D; portuguese - ru-RU &#x3D; russian - es-ES &#x3D; spanish  (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @param maxRidesharingDirectPathDuration limit duration of direct path in ridesharing, used ONLY in distributed scenario (optional)
     * @param maxBssDirectPathDuration limit duration of direct path in bss, used ONLY in distributed scenario (optional)
     * @param maxWalkingDirectPathDuration limit duration of direct path in walking, used ONLY in distributed scenario (optional)
     * @param maxCarNoParkDirectPathDuration limit duration of direct path in car_no_park, used ONLY in distributed scenario (optional)
     * @param maxBikeDirectPathDuration limit duration of direct path in bike, used ONLY in distributed scenario (optional)
     * @param maxCarDirectPathDuration limit duration of direct path in car, used ONLY in distributed scenario (optional)
     * @param maxTaxiDirectPathDuration limit duration of direct path in taxi, used ONLY in distributed scenario (optional)
     * @param depth The depth of your object (optional, default to 1)
     * @param maxWaitingDuration A journey containing a waiting section with a duration greater or equal to  max_waiting_duration will be discarded. Units : seconds. Must be &gt; 0. Default value : 4h (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getCoverageRegionJourneysAsync(String region, String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, String language, Boolean equipmentDetails, Integer maxRidesharingDirectPathDuration, Integer maxBssDirectPathDuration, Integer maxWalkingDirectPathDuration, Integer maxCarNoParkDirectPathDuration, Integer maxBikeDirectPathDuration, Integer maxCarDirectPathDuration, Integer maxTaxiDirectPathDuration, Integer depth, Integer maxWaitingDuration, final ApiCallback<Journeys> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCoverageRegionJourneysValidateBeforeCall(region, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, maxCarNoParkDurationToPt, maxTaxiDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, carNoParkSpeed, taxiSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, directPathMode, partnerServices, additionalTimeAfterFirstSectionTaxi, additionalTimeBeforeLastSectionTaxi, criteria, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, language, equipmentDetails, maxRidesharingDirectPathDuration, maxBssDirectPathDuration, maxWalkingDirectPathDuration, maxCarNoParkDirectPathDuration, maxBikeDirectPathDuration, maxCarDirectPathDuration, maxTaxiDirectPathDuration, depth, maxWaitingDuration, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Journeys>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getJourneys
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param maxCarNoParkDurationToPt Maximal duration of car no park on public transport in second (optional)
     * @param maxTaxiDurationToPt Maximal duration of taxi on public transport in second, only available in distributed scenario (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carNoParkSpeed Driving speed without car park for the fallback sections. Speed unit must be in meter/second (optional)
     * @param taxiSpeed taxi speed speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;realtime&#39; - Use all realtime information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule. (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param directPathMode Force the direct-path modes.If this list is not empty, we only compute direct_path for modes in this listAnd filter all the direct_paths of modes in first_section_mode[] (optional)
     * @param partnerServices Expose only the partner type into the response. (optional)
     * @param additionalTimeAfterFirstSectionTaxi the additional time added to the taxi section, right after riding the taxi but before hopping on the public transit (optional)
     * @param additionalTimeBeforeLastSectionTaxi the additional time added to the taxi section, right before riding the taxi but after hopping off the public transit (optional)
     * @param criteria choose the criteria used to compute pt journeys, feature in beta  (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param language Here, select a specific language for guidance instruction. list available: - nl-NL &#x3D; dutch - en-US | en-GB &#x3D; english - fr-FR &#x3D; french - de-DE &#x3D; german - hi-IN &#x3D; hindi - it-IT &#x3D; italian - ja-JP &#x3D; japanese - pt-PT &#x3D; portuguese - ru-RU &#x3D; russian - es-ES &#x3D; spanish  (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @param maxRidesharingDirectPathDuration limit duration of direct path in ridesharing, used ONLY in distributed scenario (optional)
     * @param maxBssDirectPathDuration limit duration of direct path in bss, used ONLY in distributed scenario (optional)
     * @param maxWalkingDirectPathDuration limit duration of direct path in walking, used ONLY in distributed scenario (optional)
     * @param maxCarNoParkDirectPathDuration limit duration of direct path in car_no_park, used ONLY in distributed scenario (optional)
     * @param maxBikeDirectPathDuration limit duration of direct path in bike, used ONLY in distributed scenario (optional)
     * @param maxCarDirectPathDuration limit duration of direct path in car, used ONLY in distributed scenario (optional)
     * @param maxTaxiDirectPathDuration limit duration of direct path in taxi, used ONLY in distributed scenario (optional)
     * @param depth The depth of your object (optional, default to 1)
     * @param maxWaitingDuration A journey containing a waiting section with a duration greater or equal to  max_waiting_duration will be discarded. Units : seconds. Must be &gt; 0. Default value : 4h (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getJourneysCall(String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, String language, Boolean equipmentDetails, Integer maxRidesharingDirectPathDuration, Integer maxBssDirectPathDuration, Integer maxWalkingDirectPathDuration, Integer maxCarNoParkDirectPathDuration, Integer maxBikeDirectPathDuration, Integer maxCarDirectPathDuration, Integer maxTaxiDirectPathDuration, Integer depth, Integer maxWaitingDuration, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/journeys";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (from != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("from", from));
        if (to != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("to", to));
        if (datetime != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("datetime", datetime));
        if (datetimeRepresents != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("datetime_represents", datetimeRepresents));
        if (maxNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_nb_transfers", maxNbTransfers));
        if (minNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("min_nb_transfers", minNbTransfers));
        if (firstSectionMode != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "first_section_mode[]", firstSectionMode));
        if (lastSectionMode != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "last_section_mode[]", lastSectionMode));
        if (maxDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_duration_to_pt", maxDurationToPt));
        if (maxWalkingDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_walking_duration_to_pt", maxWalkingDurationToPt));
        if (maxBikeDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_bike_duration_to_pt", maxBikeDurationToPt));
        if (maxBssDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_bss_duration_to_pt", maxBssDurationToPt));
        if (maxCarDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_car_duration_to_pt", maxCarDurationToPt));
        if (maxRidesharingDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_ridesharing_duration_to_pt", maxRidesharingDurationToPt));
        if (maxCarNoParkDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_car_no_park_duration_to_pt", maxCarNoParkDurationToPt));
        if (maxTaxiDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_taxi_duration_to_pt", maxTaxiDurationToPt));
        if (walkingSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("walking_speed", walkingSpeed));
        if (bikeSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("bike_speed", bikeSpeed));
        if (bssSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("bss_speed", bssSpeed));
        if (carSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("car_speed", carSpeed));
        if (ridesharingSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("ridesharing_speed", ridesharingSpeed));
        if (carNoParkSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("car_no_park_speed", carNoParkSpeed));
        if (taxiSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("taxi_speed", taxiSpeed));
        if (forbiddenUris != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "forbidden_uris[]", forbiddenUris));
        if (allowedId != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "allowed_id[]", allowedId));
        if (disruptionActive != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("disruption_active", disruptionActive));
        if (dataFreshness != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("data_freshness", dataFreshness));
        if (maxDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_duration", maxDuration));
        if (wheelchair != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("wheelchair", wheelchair));
        if (travelerType != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("traveler_type", travelerType));
        if (directPath != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("direct_path", directPath));
        if (freeRadiusFrom != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("free_radius_from", freeRadiusFrom));
        if (freeRadiusTo != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("free_radius_to", freeRadiusTo));
        if (directPathMode != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "direct_path_mode[]", directPathMode));
        if (partnerServices != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "partner_services[]", partnerServices));
        if (additionalTimeAfterFirstSectionTaxi != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("additional_time_after_first_section_taxi", additionalTimeAfterFirstSectionTaxi));
        if (additionalTimeBeforeLastSectionTaxi != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("additional_time_before_last_section_taxi", additionalTimeBeforeLastSectionTaxi));
        if (criteria != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("criteria", criteria));
        if (count != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("count", count));
        if (isJourneySchedules != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("is_journey_schedules", isJourneySchedules));
        if (minNbJourneys != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("min_nb_journeys", minNbJourneys));
        if (maxNbJourneys != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_nb_journeys", maxNbJourneys));
        if (bssStands != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("bss_stands", bssStands));
        if (addPoiInfos != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "add_poi_infos[]", addPoiInfos));
        if (timeframeDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("timeframe_duration", timeframeDuration));
        if (language != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("language", language));
        if (equipmentDetails != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("equipment_details", equipmentDetails));
        if (maxRidesharingDirectPathDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_ridesharing_direct_path_duration", maxRidesharingDirectPathDuration));
        if (maxBssDirectPathDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_bss_direct_path_duration", maxBssDirectPathDuration));
        if (maxWalkingDirectPathDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_walking_direct_path_duration", maxWalkingDirectPathDuration));
        if (maxCarNoParkDirectPathDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_car_no_park_direct_path_duration", maxCarNoParkDirectPathDuration));
        if (maxBikeDirectPathDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_bike_direct_path_duration", maxBikeDirectPathDuration));
        if (maxCarDirectPathDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_car_direct_path_duration", maxCarDirectPathDuration));
        if (maxTaxiDirectPathDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_taxi_direct_path_duration", maxTaxiDirectPathDuration));
        if (depth != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("depth", depth));
        if (maxWaitingDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("max_waiting_duration", maxWaitingDuration));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        if (headers != null) {
            localVarHeaderParams.putAll(headers);
        }
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getJourneysValidateBeforeCall(String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, String language, Boolean equipmentDetails, Integer maxRidesharingDirectPathDuration, Integer maxBssDirectPathDuration, Integer maxWalkingDirectPathDuration, Integer maxCarNoParkDirectPathDuration, Integer maxBikeDirectPathDuration, Integer maxCarDirectPathDuration, Integer maxTaxiDirectPathDuration, Integer depth, Integer maxWaitingDuration, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {


        com.squareup.okhttp.Call call = getJourneysCall(from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, maxCarNoParkDurationToPt, maxTaxiDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, carNoParkSpeed, taxiSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, directPathMode, partnerServices, additionalTimeAfterFirstSectionTaxi, additionalTimeBeforeLastSectionTaxi, criteria, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, language, equipmentDetails, maxRidesharingDirectPathDuration, maxBssDirectPathDuration, maxWalkingDirectPathDuration, maxCarNoParkDirectPathDuration, maxBikeDirectPathDuration, maxCarDirectPathDuration, maxTaxiDirectPathDuration, depth, maxWaitingDuration, progressListener, progressRequestListener);
        return call;

    }

    /**
     *
     *
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param maxCarNoParkDurationToPt Maximal duration of car no park on public transport in second (optional)
     * @param maxTaxiDurationToPt Maximal duration of taxi on public transport in second, only available in distributed scenario (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carNoParkSpeed Driving speed without car park for the fallback sections. Speed unit must be in meter/second (optional)
     * @param taxiSpeed taxi speed speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;realtime&#39; - Use all realtime information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule. (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param directPathMode Force the direct-path modes.If this list is not empty, we only compute direct_path for modes in this listAnd filter all the direct_paths of modes in first_section_mode[] (optional)
     * @param partnerServices Expose only the partner type into the response. (optional)
     * @param additionalTimeAfterFirstSectionTaxi the additional time added to the taxi section, right after riding the taxi but before hopping on the public transit (optional)
     * @param additionalTimeBeforeLastSectionTaxi the additional time added to the taxi section, right before riding the taxi but after hopping off the public transit (optional)
     * @param criteria choose the criteria used to compute pt journeys, feature in beta  (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param language Here, select a specific language for guidance instruction. list available: - nl-NL &#x3D; dutch - en-US | en-GB &#x3D; english - fr-FR &#x3D; french - de-DE &#x3D; german - hi-IN &#x3D; hindi - it-IT &#x3D; italian - ja-JP &#x3D; japanese - pt-PT &#x3D; portuguese - ru-RU &#x3D; russian - es-ES &#x3D; spanish  (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @param maxRidesharingDirectPathDuration limit duration of direct path in ridesharing, used ONLY in distributed scenario (optional)
     * @param maxBssDirectPathDuration limit duration of direct path in bss, used ONLY in distributed scenario (optional)
     * @param maxWalkingDirectPathDuration limit duration of direct path in walking, used ONLY in distributed scenario (optional)
     * @param maxCarNoParkDirectPathDuration limit duration of direct path in car_no_park, used ONLY in distributed scenario (optional)
     * @param maxBikeDirectPathDuration limit duration of direct path in bike, used ONLY in distributed scenario (optional)
     * @param maxCarDirectPathDuration limit duration of direct path in car, used ONLY in distributed scenario (optional)
     * @param maxTaxiDirectPathDuration limit duration of direct path in taxi, used ONLY in distributed scenario (optional)
     * @param depth The depth of your object (optional, default to 1)
     * @param maxWaitingDuration A journey containing a waiting section with a duration greater or equal to  max_waiting_duration will be discarded. Units : seconds. Must be &gt; 0. Default value : 4h (optional)
     * @return Journeys
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public Journeys getJourneys(String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, String language, Boolean equipmentDetails, Integer maxRidesharingDirectPathDuration, Integer maxBssDirectPathDuration, Integer maxWalkingDirectPathDuration, Integer maxCarNoParkDirectPathDuration, Integer maxBikeDirectPathDuration, Integer maxCarDirectPathDuration, Integer maxTaxiDirectPathDuration, Integer depth, Integer maxWaitingDuration) throws ApiException {
        ApiResponse<Journeys> resp = getJourneysWithHttpInfo(from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, maxCarNoParkDurationToPt, maxTaxiDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, carNoParkSpeed, taxiSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, directPathMode, partnerServices, additionalTimeAfterFirstSectionTaxi, additionalTimeBeforeLastSectionTaxi, criteria, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, language, equipmentDetails, maxRidesharingDirectPathDuration, maxBssDirectPathDuration, maxWalkingDirectPathDuration, maxCarNoParkDirectPathDuration, maxBikeDirectPathDuration, maxCarDirectPathDuration, maxTaxiDirectPathDuration, depth, maxWaitingDuration);
        return resp.getData();
    }

    /**
     *
     *
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param maxCarNoParkDurationToPt Maximal duration of car no park on public transport in second (optional)
     * @param maxTaxiDurationToPt Maximal duration of taxi on public transport in second, only available in distributed scenario (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carNoParkSpeed Driving speed without car park for the fallback sections. Speed unit must be in meter/second (optional)
     * @param taxiSpeed taxi speed speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;realtime&#39; - Use all realtime information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule. (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param directPathMode Force the direct-path modes.If this list is not empty, we only compute direct_path for modes in this listAnd filter all the direct_paths of modes in first_section_mode[] (optional)
     * @param partnerServices Expose only the partner type into the response. (optional)
     * @param additionalTimeAfterFirstSectionTaxi the additional time added to the taxi section, right after riding the taxi but before hopping on the public transit (optional)
     * @param additionalTimeBeforeLastSectionTaxi the additional time added to the taxi section, right before riding the taxi but after hopping off the public transit (optional)
     * @param criteria choose the criteria used to compute pt journeys, feature in beta  (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param language Here, select a specific language for guidance instruction. list available: - nl-NL &#x3D; dutch - en-US | en-GB &#x3D; english - fr-FR &#x3D; french - de-DE &#x3D; german - hi-IN &#x3D; hindi - it-IT &#x3D; italian - ja-JP &#x3D; japanese - pt-PT &#x3D; portuguese - ru-RU &#x3D; russian - es-ES &#x3D; spanish  (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @param maxRidesharingDirectPathDuration limit duration of direct path in ridesharing, used ONLY in distributed scenario (optional)
     * @param maxBssDirectPathDuration limit duration of direct path in bss, used ONLY in distributed scenario (optional)
     * @param maxWalkingDirectPathDuration limit duration of direct path in walking, used ONLY in distributed scenario (optional)
     * @param maxCarNoParkDirectPathDuration limit duration of direct path in car_no_park, used ONLY in distributed scenario (optional)
     * @param maxBikeDirectPathDuration limit duration of direct path in bike, used ONLY in distributed scenario (optional)
     * @param maxCarDirectPathDuration limit duration of direct path in car, used ONLY in distributed scenario (optional)
     * @param maxTaxiDirectPathDuration limit duration of direct path in taxi, used ONLY in distributed scenario (optional)
     * @param depth The depth of your object (optional, default to 1)
     * @param maxWaitingDuration A journey containing a waiting section with a duration greater or equal to  max_waiting_duration will be discarded. Units : seconds. Must be &gt; 0. Default value : 4h (optional)
     * @return ApiResponse&lt;Journeys&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Journeys> getJourneysWithHttpInfo(String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, String language, Boolean equipmentDetails, Integer maxRidesharingDirectPathDuration, Integer maxBssDirectPathDuration, Integer maxWalkingDirectPathDuration, Integer maxCarNoParkDirectPathDuration, Integer maxBikeDirectPathDuration, Integer maxCarDirectPathDuration, Integer maxTaxiDirectPathDuration, Integer depth, Integer maxWaitingDuration) throws ApiException {
        com.squareup.okhttp.Call call = getJourneysValidateBeforeCall(from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, maxCarNoParkDurationToPt, maxTaxiDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, carNoParkSpeed, taxiSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, directPathMode, partnerServices, additionalTimeAfterFirstSectionTaxi, additionalTimeBeforeLastSectionTaxi, criteria, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, language, equipmentDetails, maxRidesharingDirectPathDuration, maxBssDirectPathDuration, maxWalkingDirectPathDuration, maxCarNoParkDirectPathDuration, maxBikeDirectPathDuration, maxCarDirectPathDuration, maxTaxiDirectPathDuration, depth, maxWaitingDuration, null, null);
        Type localVarReturnType = new TypeToken<Journeys>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     *
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximum allowed duration to reach the public transport (same limit used before and after public transport). Use this to limit the walking/biking part. Unit is seconds (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param maxRidesharingDurationToPt Maximal duration of ridesharing on public transport in second (optional)
     * @param maxCarNoParkDurationToPt Maximal duration of car no park on public transport in second (optional)
     * @param maxTaxiDurationToPt Maximal duration of taxi on public transport in second, only available in distributed scenario (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param ridesharingSpeed ridesharing speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carNoParkSpeed Driving speed without car park for the fallback sections. Speed unit must be in meter/second (optional)
     * @param taxiSpeed taxi speed speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;realtime&#39; - Use all realtime information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule. (optional)
     * @param maxDuration Maximum duration of journeys in seconds (from &#x60;datetime&#x60; parameter). More usefull when computing an isochrone (only &#x60;from&#x60; or &#x60;to&#x60; is provided). On a classic journey (from-to), it will mostly speedup Navitia: You may have journeys a bit longer than that value (you would have to filter them). (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param freeRadiusFrom Radius length (in meters) around the coordinates of departure in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param freeRadiusTo Radius length (in meters) around the coordinates of arrival in which the stop points are considered free to go (crowfly&#x3D;0) (optional)
     * @param directPathMode Force the direct-path modes.If this list is not empty, we only compute direct_path for modes in this listAnd filter all the direct_paths of modes in first_section_mode[] (optional)
     * @param partnerServices Expose only the partner type into the response. (optional)
     * @param additionalTimeAfterFirstSectionTaxi the additional time added to the taxi section, right after riding the taxi but before hopping on the public transit (optional)
     * @param additionalTimeBeforeLastSectionTaxi the additional time added to the taxi section, right before riding the taxi but after hopping off the public transit (optional)
     * @param criteria choose the criteria used to compute pt journeys, feature in beta  (optional)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys, must be &gt;&#x3D; 0 (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys, must be &gt; 0 (optional)
     * @param bssStands DEPRECATED, Use add_poi_infos[]&#x3D;bss_stands (optional)
     * @param addPoiInfos Show more information about the poi if it&#39;s available, for instance, show BSS/car park availability in the pois(BSS/car park) of response (optional)
     * @param timeframeDuration Minimum timeframe to search journeys. For example &#39;timeframe_duration&#x3D;3600&#39; will search for all interesting journeys departing within the next hour. Nota 1: Navitia can return journeys after that timeframe as it&#39;s actually a minimum. Nota 2: &#39;max_nb_journeys&#39; parameter has priority over &#39;timeframe_duration&#39; parameter. (optional)
     * @param language Here, select a specific language for guidance instruction. list available: - nl-NL &#x3D; dutch - en-US | en-GB &#x3D; english - fr-FR &#x3D; french - de-DE &#x3D; german - hi-IN &#x3D; hindi - it-IT &#x3D; italian - ja-JP &#x3D; japanese - pt-PT &#x3D; portuguese - ru-RU &#x3D; russian - es-ES &#x3D; spanish  (optional)
     * @param equipmentDetails enhance response with accessibility equipement details (optional, default to True)
     * @param maxRidesharingDirectPathDuration limit duration of direct path in ridesharing, used ONLY in distributed scenario (optional)
     * @param maxBssDirectPathDuration limit duration of direct path in bss, used ONLY in distributed scenario (optional)
     * @param maxWalkingDirectPathDuration limit duration of direct path in walking, used ONLY in distributed scenario (optional)
     * @param maxCarNoParkDirectPathDuration limit duration of direct path in car_no_park, used ONLY in distributed scenario (optional)
     * @param maxBikeDirectPathDuration limit duration of direct path in bike, used ONLY in distributed scenario (optional)
     * @param maxCarDirectPathDuration limit duration of direct path in car, used ONLY in distributed scenario (optional)
     * @param maxTaxiDirectPathDuration limit duration of direct path in taxi, used ONLY in distributed scenario (optional)
     * @param depth The depth of your object (optional, default to 1)
     * @param maxWaitingDuration A journey containing a waiting section with a duration greater or equal to  max_waiting_duration will be discarded. Units : seconds. Must be &gt; 0. Default value : 4h (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getJourneysAsync(String from, String to, OffsetDateTime datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Integer maxRidesharingDurationToPt, Integer maxCarNoParkDurationToPt, Integer maxTaxiDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, Float ridesharingSpeed, Float carNoParkSpeed, Float taxiSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer freeRadiusFrom, Integer freeRadiusTo, List<String> directPathMode, List<String> partnerServices, Integer additionalTimeAfterFirstSectionTaxi, Integer additionalTimeBeforeLastSectionTaxi, String criteria, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, List<String> addPoiInfos, Integer timeframeDuration, String language, Boolean equipmentDetails, Integer maxRidesharingDirectPathDuration, Integer maxBssDirectPathDuration, Integer maxWalkingDirectPathDuration, Integer maxCarNoParkDirectPathDuration, Integer maxBikeDirectPathDuration, Integer maxCarDirectPathDuration, Integer maxTaxiDirectPathDuration, Integer depth, Integer maxWaitingDuration, final ApiCallback<Journeys> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getJourneysValidateBeforeCall(from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, maxRidesharingDurationToPt, maxCarNoParkDurationToPt, maxTaxiDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, ridesharingSpeed, carNoParkSpeed, taxiSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, freeRadiusFrom, freeRadiusTo, directPathMode, partnerServices, additionalTimeAfterFirstSectionTaxi, additionalTimeBeforeLastSectionTaxi, criteria, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, addPoiInfos, timeframeDuration, language, equipmentDetails, maxRidesharingDirectPathDuration, maxBssDirectPathDuration, maxWalkingDirectPathDuration, maxCarNoParkDirectPathDuration, maxBikeDirectPathDuration, maxCarDirectPathDuration, maxTaxiDirectPathDuration, depth, maxWaitingDuration, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Journeys>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
